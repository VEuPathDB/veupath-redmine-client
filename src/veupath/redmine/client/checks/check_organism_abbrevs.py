#!/usr/bin/env python
# See the NOTICE file distributed with this work for additional information
# regarding copyright ownership.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Check and generate organism abbreviations for genome Redmine issues from VeupathDB."""

import argparse
from os import PathLike
from typing import Dict, List, Union

from .. import VeupathRedmineClient
from ..genome import Genome
from ..redmine_issue import RedmineIssue
from ..orgs_utils import InvalidAbbrev, InvalidOrganism, OrgsUtils


supported_team = "Data Processing (EBI)"
supported_status_id = 20


def get_genome_issues(redmine: VeupathRedmineClient) -> list:
    """Get issues for all genomes"""

    redmine.add_filter("team", supported_team)

    genomes = []
    for datatype in Genome.supported_datatypes:
        redmine.add_filter("datatype", datatype)
        issues = redmine.get_issues()
        print(f"{len(issues)} issues for datatype '{datatype}'")
        genomes += issues
        redmine.remove_filter("datatype")
    print(f"{len(genomes)} issues for genomes")

    return genomes


def categorize_abbrevs(
    issues: List[RedmineIssue], cur_abbrevs_path: Union[PathLike, None] = None
) -> Dict[str, List[Genome]]:
    """Returns a dict of lists of genome issues depending on their categorization.

    Categories (might overlap):
        set_new = the issue has an abbrev already, and it is new
        set_replacement = the issue has an abbrev already, which is not new but ok since it's a replacement
        to_update = the issue has no abbrev, but it can be generated by us and it would be new
        invalid = the abbrev (from the issue or generated) has an invalid format
        duplicate = the abbrev is already being used in this same list
        used_abbrev = the abbrev (from the issue or generated) is not new and it's not a replacement
        unknown_replacement = the abbrev is new but it should not be because it's a replacement
        ...
    """
    cur_abbrevs = OrgsUtils.load_abbrevs(cur_abbrevs_path)
    category: Dict[str, List[Genome]] = {
        "set_new": [],
        "set_replacement": [],
        "to_update": [],
        "invalid": [],
        "duplicate": [],
        "used_abbrev": [],
        "unknown_replacement": [],
    }

    previous_names = set()
    for issue in issues:
        genome = Genome(issue)
        genome.parse()
        new_abbrev = False
        valid_abbrev = False
        used_abbrev = False
        duplicate = False

        # Create new organism abbrev if necessary
        if not genome.organism_abbrev:
            exp_organism = genome.experimental_organism
            try:
                new_org = OrgsUtils.generate_abbrev(exp_organism)
            except InvalidOrganism:
                genome.organism_abbrev = ""
            else:
                genome.organism_abbrev = new_org
                new_abbrev = True

        # Check that the format of the abbrev is valid
        try:
            OrgsUtils.validate_abbrev(genome.organism_abbrev)
            valid_abbrev = True
        except InvalidAbbrev:
            valid_abbrev = False

        # Check if the abbrev is already in use
        if genome.organism_abbrev.lower() in cur_abbrevs:
            used_abbrev = True

        if genome.organism_abbrev in previous_names:
            duplicate = True
        else:
            previous_names.update([genome.organism_abbrev])

        # Categorize
        if not valid_abbrev:
            category["invalid"].append(genome)
        elif duplicate:
            category["duplicate"].append(genome)
        else:
            if used_abbrev:
                if genome.is_replacement:
                    if new_abbrev:
                        category["to_update"].append(genome)
                    else:
                        category["set_replacement"].append(genome)
                else:
                    category["used_abbrev"].append(genome)
            else:
                if genome.is_replacement:
                    category["unknown_replacement"].append(genome)
                else:
                    if new_abbrev:
                        category["to_update"].append(genome)
                    else:
                        category["set_new"].append(genome)

    return category


def check_abbrevs(issues: List[RedmineIssue], cur_abbrevs_path: Union[PathLike, None] = None) -> None:
    """Print the issues in all the categories."""
    categories = categorize_abbrevs(issues, cur_abbrevs_path)

    for cat in (
        "invalid",
        "duplicate",
        "used_abbrev",
        "unknown_replacement",
        "set_new",
        "set_replacement",
        "to_update",
    ):
        cat_genomes = categories[cat]
        if len(cat_genomes) == 0:
            continue
        print(f"\n{len(cat_genomes)} {cat.upper()} organism abbrevs:")
        for genome in cat_genomes:
            new_org = genome.organism_abbrev
            line = [f"{new_org:20}", str(genome.issue.id)]
            line.append(f"From {genome.experimental_organism}")
            print("\t".join(line))


def update_abbrevs(
    redmine: VeupathRedmineClient, issues: List[RedmineIssue], cur_abbrevs_path: Union[PathLike, None]
) -> None:
    """Update the OrganismAbbrev field in all the Redmine issues where we can generate one."""
    categories = categorize_abbrevs(issues, cur_abbrevs_path)
    to_name = categories["to_update"]
    print(f"\n{len(to_name)} new organism abbrevs to update:")
    for genome in to_name:
        new_org = genome.organism_abbrev
        line = [f"{new_org:20}", str(genome.issue.id)]
        status = redmine.update_custom_value(genome, "Organism Abbreviation", new_org)
        if status:
            line.append("UPDATED")
        else:
            line.append("UPDATE FAILED")
        print("\t".join(line))


def main():
    """Main entrypoint."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="List and generate organism_abbrevs from Redmine")

    parser.add_argument("--key", type=str, help="Redmine authentication key")

    parser.add_argument(
        "--check",
        action="store_true",
        dest="check",
        help="Show the organism_abbrev status for the selected issues",
    )
    parser.add_argument(
        "--update",
        action="store_true",
        dest="update",
        help="Actually update the organism_abbrevs for the selected issues",
    )

    # Optional
    parser.add_argument("--build", type=int, help="Restrict to a given build")

    parser.add_argument(
        "--current_abbrevs", type=str, required=False, help="Path to a list of current abbrevs"
    )

    parser.add_argument("--validate", type=str, help="Check the validity of one abbreviation")
    parser.add_argument("--generate_abbrev", type=str, help="Generate an abbrev from a species full name")

    args = parser.parse_args()

    if args.validate:
        try:
            OrgsUtils.validate_abbrev(args.validate)
            print("Abbrev is valid")
        except InvalidAbbrev as ex:
            print(ex)

    elif args.generate_abbrev:
        try:
            abbrev = OrgsUtils.generate_abbrev(args.generate_abbrev)
            print(f"Abbrev for '{args.generate_abbrev}' is '{abbrev}'")
        except InvalidOrganism as ex:
            print(ex)

    else:
        if not args.key:
            print("Key needed")
            return

        # Start Redmine API
        redmine = VeupathRedmineClient(key=args.key)
        if args.build:
            redmine.set_build(args.build)

        issues = get_genome_issues(redmine)

        if args.check:
            check_abbrevs(issues, args.current_abbrevs)
        elif args.update:
            update_abbrevs(redmine, issues, args.current_abbrevs)


if __name__ == "__main__":
    main()
